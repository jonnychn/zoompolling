<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoom Polling Data Visualizer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for better readability -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for table and canvas responsiveness */
        .table-container, .chart-container {
            overflow-x: auto; /* Allows horizontal scrolling on small screens */
        }
        canvas {
            display: block;
            background-color: #f9fafb; /* Light gray background for canvas */
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid #e5e7eb; /* border border-gray-200 */
        }
        th {
            cursor: pointer; /* Indicate sortable columns */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white rounded-lg shadow-xl p-8 max-w-2xl w-full">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Zoom Polling Data Visualizer</h1>

        <!-- Privacy Message Section -->
        <div class="bg-green-50 border border-green-200 text-green-800 px-4 py-3 rounded-md mb-6" role="alert">
            <div class="flex items-start">
                <div class="py-1">
                    <svg class="h-5 w-5 text-green-500 mr-3" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l3 3a1 1 0 001.414-1.414L11 9.586V6z" clip-rule="evenodd"></path>
                    </svg>
                </div>
                <div>
                    <p class="font-semibold text-lg mb-1">Privacy</p>
                    <p class="text-sm">
                        Rest assured, your data is processed and saved locally within your browser.
                        It is never sent to any server.
                        Think of it like creating an Excel file directly on your computer â€“ your information stays private and secure on your device.
                    </p>
                </div>
            </div>
        </div>

        <!-- Use Cases Section -->
        <div class="bg-gray-50 border border-gray-200 text-gray-700 px-4 py-3 rounded-md mb-6">
            <h2 class="font-semibold text-xl mb-2">Use Cases</h2>
            <p class="text-sm">
                This personal, client-side Zoom Polling Data Visualizer analyzes your Zoom polling results quickly and efficiently. It processes data directly in your browser, ensuring your privacy by never sending sensitive data to an external server. This tool saves time by providing instant insights for informed decisions.
            </p>
        </div>

        <div class="mb-4">
            <label for="fileInput" class="block text-gray-700 text-sm font-medium mb-2">Upload your Zoom Polling CSV file:</label>
            <input type="file" id="fileInput" class="block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-50 file:text-blue-700
                hover:file:bg-blue-100 cursor-pointer"
                accept=".csv">
        </div>

        <div id="messageBox" class="hidden bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative mt-4" role="alert">
            <span id="messageText" class="block sm:inline"></span>
            <span class="absolute top-0 bottom-0 right-0 px-4 py-3 cursor-pointer" onclick="document.getElementById('messageBox').classList.add('hidden')">
                <svg class="fill-current h-6 w-6 text-green-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
            </span>
        </div>

        <button id="processButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
            Process Zoom Polling Data
        </button>

        <!-- Processed Data Output Section -->
        <div id="outputSection" class="mt-6 hidden">
            <!-- Chart Section -->
            <div class="chart-container mb-6 p-4 bg-gray-50 rounded-md border border-gray-200">
                <h2 class="font-semibold mb-2 text-gray-700">Polling Responses Chart</h2>
                <p id="chartQuestion" class="text-sm text-gray-600 mb-2"></p>
                <canvas id="pollingChart" class="w-full" height="300"></canvas>
            </div>

            <!-- Table Section -->
            <div class="table-container mb-6 p-4 bg-gray-50 rounded-md border border-gray-200">
                <h2 class="font-semibold mb-2 text-gray-700">Raw Polling Data</h2>
                <table id="dataTable" class="min-w-full divide-y divide-gray-200 text-sm text-gray-700">
                    <thead class="bg-gray-100">
                        <tr id="tableHeader"></tr>
                    </thead>
                    <tbody id="tableBody" class="bg-white divide-y divide-gray-200">
                        <!-- Table rows will be inserted here by JavaScript -->
                    </tbody>
                </table>
            </div>

            <!-- Download Button -->
            <button id="downloadButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                Download Processed Data (CSV)
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            const processButton = document.getElementById('processButton');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const outputSection = document.getElementById('outputSection');
            const dataTable = document.getElementById('dataTable');
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');
            const pollingChartCanvas = document.getElementById('pollingChart');
            const chartQuestionText = document.getElementById('chartQuestion');
            const downloadButton = document.getElementById('downloadButton');
            let parsedCsvData = []; // Store parsed data globally for download and sorting

            /**
             * Displays a message in the message box.
             * @param {string} message - The message to display.
             * @param {'green'|'red'} type - The type of message (green for success, red for error).
             */
            function showMessage(message, type) {
                messageText.textContent = message;
                // Reset classes
                messageBox.classList.remove('hidden', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-red-100', 'border-red-400', 'text-red-700');
                // Apply new classes based on type
                if (type === 'green') {
                    messageBox.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
                } else if (type === 'red') {
                    messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
                }
            }

            /**
             * Parses a CSV string into an array of objects.
             * Assumes the first row is the header.
             * @param {string} csvString - The CSV content as a string.
             * @returns {Array<Object>} An array of objects, where each object represents a row.
             */
            function parseCSV(csvString) {
                const lines = csvString.split(/\r?\n/).filter(line => line.trim() !== '');
                if (lines.length === 0) return [];

                const headers = lines[0].split(',').map(header => header.trim());
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(value => value.trim());
                    if (values.length === headers.length) {
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index];
                        });
                        data.push(row);
                    }
                }
                return data;
            }

            /**
             * Renders the parsed data into an HTML table.
             * @param {Array<Object>} data - The array of objects to display.
             */
            function renderTable(data) {
                tableHeader.innerHTML = '';
                tableBody.innerHTML = '';

                if (data.length === 0) return;

                const headers = Object.keys(data[0]);

                // Create table headers
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.classList.add('px-6', 'py-3', 'text-left', 'text-xs', 'font-medium', 'text-gray-500', 'uppercase', 'tracking-wider');
                    th.textContent = header;
                    th.setAttribute('data-column', header); // For sorting
                    th.addEventListener('click', () => sortTable(header));
                    tableHeader.appendChild(th);
                });

                // Create table rows
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    tr.classList.add('hover:bg-gray-50');
                    headers.forEach(header => {
                        const td = document.createElement('td');
                        td.classList.add('px-6', 'py-4', 'whitespace-nowrap');
                        td.textContent = row[header];
                        tr.appendChild(td);
                    });
                    tableBody.appendChild(tr);
                });
            }

            let sortDirection = {}; // To keep track of sort direction for each column

            /**
             * Sorts the table by the specified column.
             * @param {string} column - The column name to sort by.
             */
            function sortTable(column) {
                const isAsc = sortDirection[column] === 'asc';
                sortDirection = {}; // Reset all directions
                sortDirection[column] = isAsc ? 'desc' : 'asc'; // Toggle direction for current column

                parsedCsvData.sort((a, b) => {
                    const valA = a[column];
                    const valB = b[column];

                    if (typeof valA === 'string' && typeof valB === 'string') {
                        return isAsc ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    }
                    // For numbers, convert and compare
                    const numA = parseFloat(valA);
                    const numB = parseFloat(valB);
                    if (!isNaN(numA) && !isNaN(numB)) {
                        return isAsc ? numA - numB : numB - numA;
                    }
                    return 0; // Fallback
                });
                renderTable(parsedCsvData); // Re-render the table with sorted data
            }


            /**
             * Draws a bar chart on the canvas for the first detected polling question.
             * @param {Array<Object>} data - The parsed CSV data.
             */
            function drawChart(data) {
                const ctx = pollingChartCanvas.getContext('2d');
                ctx.clearRect(0, 0, pollingChartCanvas.width, pollingChartCanvas.height); // Clear previous chart

                if (data.length === 0) {
                    chartQuestionText.textContent = "No data available for charting.";
                    return;
                }

                // Find the first "Question X" and "Answer X" pair
                let questionColumn = null;
                let answerColumn = null;
                const headers = Object.keys(data[0]);

                for (let i = 0; i < headers.length; i++) {
                    if (headers[i].startsWith('Question')) {
                        questionColumn = headers[i];
                        // Assuming Answer column is next to Question column, e.g., "Answer 1" for "Question 1"
                        if (i + 1 < headers.length && headers[i+1].startsWith('Answer')) {
                            answerColumn = headers[i+1];
                            break;
                        }
                    }
                }

                if (!questionColumn || !answerColumn) {
                    chartQuestionText.textContent = "Could not find 'Question' and 'Answer' columns for charting.";
                    return;
                }

                // Aggregate answers for the first question
                const answerCounts = {};
                data.forEach(row => {
                    const answer = row[answerColumn];
                    if (answer) {
                        answerCounts[answer] = (answerCounts[answer] || 0) + 1;
                    }
                });

                const labels = Object.keys(answerCounts);
                const values = Object.values(answerCounts);

                if (labels.length === 0) {
                    chartQuestionText.textContent = `No responses found for "${data[0][questionColumn]}".`;
                    return;
                }

                chartQuestionText.textContent = `Responses for: "${data[0][questionColumn]}"`;

                // Chart drawing parameters
                const chartWidth = pollingChartCanvas.width;
                const chartHeight = pollingChartCanvas.height;
                const barWidth = 40;
                const spacing = 20;
                const maxBarHeight = chartHeight * 0.7; // Max height for bars
                const maxValue = Math.max(...values);
                const startX = 50; // Padding from left
                const startY = chartHeight - 50; // Padding from bottom
                const axisColor = '#6b7280'; // gray-500
                const barColor = '#3b82f6'; // blue-500
                const textColor = '#1f2937'; // gray-800

                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';

                // Draw Y-axis (values)
                ctx.beginPath();
                ctx.strokeStyle = axisColor;
                ctx.moveTo(startX, startY);
                ctx.lineTo(startX, startY - maxBarHeight - 20); // Extend a bit above max bar
                ctx.stroke();

                // Draw X-axis (labels)
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(chartWidth - 20, startY);
                ctx.stroke();

                // Draw bars
                labels.forEach((label, index) => {
                    const value = values[index];
                    const barHeight = (value / maxValue) * maxBarHeight;
                    const x = startX + index * (barWidth + spacing) + spacing / 2;
                    const y = startY - barHeight;

                    // Draw bar
                    ctx.fillStyle = barColor;
                    ctx.fillRect(x, y, barWidth, barHeight);

                    // Draw value on top of bar
                    ctx.fillStyle = textColor;
                    ctx.fillText(value, x + barWidth / 2, y - 5);

                    // Draw label below bar
                    ctx.fillText(label, x + barWidth / 2, startY + 20);
                });

                // Draw Y-axis labels (simple scale)
                ctx.textAlign = 'right';
                ctx.fillStyle = textColor;
                for (let i = 0; i <= 5; i++) { // 0, 25%, 50%, 75%, 100% of max value
                    const yValue = (maxValue / 5) * i;
                    const yPos = startY - (yValue / maxValue) * maxBarHeight;
                    ctx.fillText(Math.round(yValue), startX - 5, yPos + 4);
                    ctx.beginPath();
                    ctx.strokeStyle = '#e5e7eb'; // light gray grid line
                    ctx.moveTo(startX, yPos);
                    ctx.lineTo(chartWidth - 20, yPos);
                    ctx.stroke();
                }
            }

            /**
             * Handles resizing of the window to make the chart responsive.
             */
            function resizeChart() {
                // Set canvas width to its parent container's width
                const container = pollingChartCanvas.parentElement;
                pollingChartCanvas.width = container.clientWidth;
                // Redraw chart if data exists
                if (parsedCsvData && parsedCsvData.length > 0) {
                    drawChart(parsedCsvData);
                }
            }

            // Initial resize and add event listener
            window.addEventListener('resize', resizeChart);


            /**
             * Triggers a download of the provided data as a CSV file.
             * @param {Array<Object>} data - The data to download.
             * @param {string} filename - The name of the file.
             */
            function downloadCSV(data, filename = 'processed_polling_data.csv') {
                if (data.length === 0) {
                    showMessage('No data to download!', 'red');
                    return;
                }

                const headers = Object.keys(data[0]);
                const csvRows = [];

                // Add headers
                csvRows.push(headers.join(','));

                // Add data rows
                data.forEach(row => {
                    const values = headers.map(header => {
                        const escaped = ('' + row[header]).replace(/"/g, '""'); // Escape double quotes
                        return `"${escaped}"`; // Enclose all values in double quotes
                    });
                    csvRows.push(values.join(','));
                });

                const csvString = csvRows.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                if (link.download !== undefined) { // Feature detection
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showMessage('Data downloaded successfully!', 'green');
                } else {
                    showMessage('Your browser does not support downloading files directly. Please copy the data manually.', 'red');
                }
            }

            // Event listener for the process button
            processButton.addEventListener('click', () => {
                const file = fileInput.files[0];
                if (!file) {
                    showMessage('Please select a Zoom Polling CSV file first!', 'red');
                    return;
                }

                // Ensure only CSV files are accepted
                if (!file.name.endsWith('.csv')) {
                    showMessage('Please upload a CSV file.', 'red');
                    return;
                }

                const reader = new FileReader();

                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        parsedCsvData = parseCSV(content); // Parse the entire CSV
                        if (parsedCsvData.length > 0) {
                            renderTable(parsedCsvData); // Render the table
                            resizeChart(); // Set canvas size and draw chart
                            outputSection.classList.remove('hidden'); // Show output sections
                            showMessage('Zoom Polling data processed successfully! Table and chart generated.', 'green');
                        } else {
                            showMessage('The CSV file is empty or could not be parsed.', 'red');
                            outputSection.classList.add('hidden');
                        }
                    } catch (error) {
                        console.error("Error processing CSV:", error);
                        showMessage('Error processing CSV file. Please check its format.', 'red');
                        outputSection.classList.add('hidden');
                    }
                };

                reader.onerror = () => {
                    showMessage('Error reading file!', 'red');
                    outputSection.classList.add('hidden');
                };

                reader.readAsText(file); // Read the entire file as text
            });

            // Event listener for the download button
            downloadButton.addEventListener('click', () => {
                downloadCSV(parsedCsvData, 'zoom_polling_results.csv');
            });
        });
    </script>
</body>
</html>
